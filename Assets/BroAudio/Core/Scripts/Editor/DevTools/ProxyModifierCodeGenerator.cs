using System.Reflection;
using System.IO;
using System;
using UnityEngine;
using System.Linq;
using System.Collections.Generic;
using UnityEditor;

namespace Ami.Extension.Reflection
{
#if BroAudio_DevOnly_GeneratedCodeSample
    public interface IAudioSourceModifierSample
    {
        float volume { set; }
    }

    public class AudioSourceModifierSample : BroModifier<AudioSource>, IAudioSourceModifierSample
    {
        public AudioSourceModifierSample(AudioSource @base) : base(@base) {}

        public const float Default_Volume = 1f;
        private bool _hasVolumeResetAction = false;
        public float volume
        {
            set
            {
                AddResetAction(ref _hasVolumeResetAction, () => Base.volume = Default_Volume);
                Base.volume = value;
            }
        }
    }
#endif

    public static class AudioSourceProxyGenerator
    {
        [MenuItem("Tools/BroAudio/Generate Audio Source Proxy")]
        public static void Generate()
        {
            ProxyModifierCodeGenerator.Parameters parameters = new ProxyModifierCodeGenerator.Parameters()
            {
                Namespace = "Ami.Extension",
                ScriptName = "AudioSourceProxy",
                Path = Path.GetFullPath("Assets/BroAudio/Core/Scripts/Player/AutoGeneratedCode"),
                Usings = new string[] { "System", "UnityEngine", "UnityEngine.Audio" },
            };

            ProxyModifierCodeGenerator.GenerateModifierCode<AudioSource>(parameters);
        }
    }

    public static partial class ProxyModifierCodeGenerator
    {
        public const string Title = "// Auto-generated code";
        public struct Parameters
        {
            public string Namespace;
            public string ScriptName;
            public string Path;
            public string[] Usings;
            public bool IncludeBaseTypeMembers;
        }

        public static void GenerateModifierCode<T>(Parameters parameters, BindingFlags bindingFlags = BindingFlags.Public | BindingFlags.Instance)
        {
            Type type = typeof(T);
            MemberInfo[] members = type.GetMembers(bindingFlags);

            if (members == null || members.Length == 0)
            {
                Debug.LogError($"No valid members in {type}, BindingFlags:{bindingFlags}");
                return;
            }

            if (!Directory.Exists(parameters.Path))
            {
                Debug.LogError($"Path:{parameters.Path} not exist!");
                return;
            }

            var filteredMembers = members
                .Where(x => x.MemberType == MemberTypes.Property && 
                (!parameters.IncludeBaseTypeMembers && x.DeclaringType == typeof(T)) &&
                x is PropertyInfo property && property.CanWrite && x.GetCustomAttribute(typeof(ObsoleteAttribute)) == null);

            CreateModifierInterface<T>(parameters, filteredMembers);
            CreateModifierClass<T>(parameters, filteredMembers);
            AssetDatabase.Refresh();
        }

        private static void CreateModifierInterface<T>(Parameters parameters, IEnumerable<MemberInfo> members)
        {
            string interfaceName = "I" + parameters.ScriptName;
            using (var file = File.CreateText(Path.Combine(parameters.Path, interfaceName + ".cs")))
            {
                file.WriteLine(Title);
                file.WriteUsings(parameters.Usings);
                file.WriteLine();

                string indent = string.Empty;
                using ( file.WriteBraces("namespace " + parameters.Namespace, ref indent))
                using ( file.WriteBraces("public interface " + interfaceName, ref indent))
                {
                    foreach (var member in members)
                    {
                        if(member is PropertyInfo property)
                        {
                            file.WriteLine(indent + string.Format("{0} {1} {{ set; }}", property.PropertyType.GetSimpleTypeName(), property.Name));
                        }
                    }
                }
            }
        }

        private static void CreateModifierClass<T>(Parameters parameters, IEnumerable<MemberInfo> members)
        {
            using (var file = File.CreateText(Path.Combine(parameters.Path, parameters.ScriptName + ".cs")))
            {
                file.WriteLine(Title);
                file.WriteUsings(parameters.Usings);

                string targetName = typeof(T).Name;
                string indent = string.Empty;
                using (file.WriteBraces("namespace " + parameters.Namespace, ref indent))
                using (file.WriteBraces("public class " + parameters.ScriptName + $" : BroModifier<{targetName}>, I" + parameters.ScriptName, ref indent))
                {
                    file.WriteLine(indent + $"public {parameters.ScriptName}({targetName} @base) : base(@base) {{}}");
                    file.WriteLine();
                    foreach (var member in members)
                    {
                        WriteSetterBody(file, indent, member);
                    }
                }
            }
        }

        private static void WriteSetterBody(StreamWriter file, string indent, MemberInfo member)
        {
            if (member is not PropertyInfo property)
            {
                return;
            }

            string typeName = property.PropertyType.GetSimpleTypeName();
            string varName = property.Name;
            string pascalVarName = varName.ToPascal();

            string varNameOfDefault = $"Default_{pascalVarName}";
            string varNameOfHasReset = $"_has{pascalVarName}ResetAction";

            // ToDo: no value
            file.WriteLine(indent + $"public const {typeName} {varNameOfDefault} = default;");
            file.WriteLine(indent + $"private bool {varNameOfHasReset} = false;");
            using (file.WriteBraces($"public {typeName} {varName}",ref indent))
            using (file.WriteBraces("set", ref indent))
            {
                file.WriteLine(indent + $"AddResetAction(ref {varNameOfHasReset}, () => Base.{varName} = {varNameOfDefault});");
                file.WriteLine(indent + $"Base.{varName} = value;");
            }
            file.WriteLine();
        }

        private static void WriteUsings(this StreamWriter writer, string[] usings)
        {
            if (usings != null)
            {
                foreach (var usage in usings)
                {
                    writer.WriteLine($"using {usage};");
                }
            }
        }

        private static string GetSimpleTypeName(this Type type) => type switch
        {
            Type f when f == typeof(float) => "float",
            Type i when i == typeof(int) => "int",
            Type b when b == typeof(bool) => "bool",
            Type l when l == typeof(long) => "long",
            Type d when d == typeof(double) => "double",
            Type c when c == typeof(char) => "char",
            Type s when s == typeof(string) => "string",
            Type o when o == typeof(object) => "object",
            _ => type.Name,
        };

        private static string ToPascal(this string str)
        {
            char[] array = str.ToCharArray();
            array[0] = array[0].ToUpper();
            return new string(array);
        }

        private static string ToCamel(this string str)
        {
            char[] array = str.ToCharArray();
            array[0] = array[0].ToLower();
            return new string(array);
        }
    }
}
